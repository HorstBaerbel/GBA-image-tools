/// @brief Find how many entries in the codebook a block can represent in regards to max. allowed error
auto findImportantBlocks(const CodeBook &codebook, double maxAllowedError, int32_t offsetMin, int32_t offsetMax, uint32_t nMostImportant) -> std::vector<int32_t>
{
    std::vector<std::pair<int32_t, int32_t>> entries(codebook.size());
    for (int32_t blockIndex = 0; blockIndex < codebook.size(); ++blockIndex)
    {
        // calculate start and end of search
        auto minIndex = blockIndex + offsetMin;
        minIndex = minIndex < 0 ? 0 : minIndex;
        minIndex = minIndex >= codebook.size() ? codebook.size() - 1 : minIndex;
        auto maxIndex = blockIndex + offsetMax;
        maxIndex = maxIndex < 0 ? 0 : maxIndex;
        maxIndex = maxIndex >= codebook.size() ? codebook.size() - 1 : maxIndex;
        // searched entries must be >= 1
        if ((maxIndex - minIndex) >= 1)
        {
            // count blocks with block errors < maxAllowedError
            auto start = std::next(codebook.cbegin(), minIndex);
            auto end = std::next(codebook.cbegin(), maxIndex);
            auto nrOfMatches = std::count_if(start, end, [&codebook, maxAllowedError, blockIndex, index = minIndex](const auto &b) mutable
                                             { return index++ != blockIndex && YCgCoRd::distanceBelowThreshold(codebook[blockIndex], b, maxAllowedError).first; });
            entries[blockIndex] = {nrOfMatches, blockIndex};
        }
    }
    // sort list
    std::sort(entries.begin(), entries.end(), [](auto &a, auto &b)
              { return a.first < b.first; });
    // get the n most important entries
    std::vector<int32_t> result;
    auto end = nMostImportant > entries.size() ? entries.cend() : std::next(entries.cbegin(), nMostImportant);
    std::transform(entries.cbegin(), end, std::back_inserter(result), [](const auto &e)
                   { return e.second; });
    return result;
}